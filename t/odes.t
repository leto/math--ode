use Test::More tests => 6;
use File::Spec;
use lib File::Spec->catfile("..","lib");
use Math::ODE;
use Data::Dumper;
use strict;
use warnings;

my ($o, $error, @vals, $res);

# analytic solution is y(x) = 2 e^{-x}
$o = new Math::ODE ( file => 'data',
			step => 0.1,
			initial => [2], 
			ODE => [ \&DE1 ], 
			t0 => 0,
			tf => 5 );
$o->evolve;
$error = $o->error;	
@vals =  $o->values_at(3);
$res = abs( $vals[0]  - 2*exp(-3) );
ok( $res < $error, "Constant Coefficient 1st order solved correctly, res=$res, expected error=$error"); 


# analytic solution is y(x) = -1/(x-1)
$o = new Math::ODE ( file => 'data',
			step => 0.01, 
			initial => [1], 
			ODE => [ \&DE2 ], 
			t0 => 0,
			tf => 0.5 );
$o->evolve;
$error = $o->error;	
@vals =  $o->values_at(0.4);
$res = abs( $vals[0]  + 1/(0.4-1) );
ok( $res < $error, "Nonlinear 1st order : res=$res, expected error=$error"); 


SKIP : {
	skip 'this keeps me up at night, where is the added numerical error coming from?', 1;
# analytic solution is y(x) = exp(-x^2)
$o = new Math::ODE ( file => 'data',
			step => 0.1, 
			initial => [1], 
			ODE => [ \&DE3 ], 
			t0 => 0,
			tf => 5 );
$o->evolve;
$error = $o->error;	
@vals =  $o->values_at(3);
$res = abs( $vals[0]  + 2*3*exp(-3**2) );
ok( $res < $error, " 1st order nonhomogeneous: res=$res, expected error=$error"); 
}
sub DE1 { my ($t,$y) = @_; -$y->[0]; }
sub DE2 { my ($t,$y) = @_; $y->[0] ** 2; }
sub DE3 { my ($t,$y) = @_; - 2 * $y->[0] * exp ( - $y->[0] ** 2 ); }

sub DE4 { my ($t,$y) = @_; $y->[0] ** 4; }
sub DE5 { my ($t,$y) = @_; $y->[0] ** 5; }

SKIP : {
	skip 'need to implement framework to test a family of similar odes with autogenerated coderefs', 2;
 
my $x = 0.25;
for my $n ( 4 .. 5 ){
	my $subs = [ 0,0,0,0, [ \&DE4 ] , [ \&DE5 ] ];
	$o = new Math::ODE (    step => 0.1, 
				initial => [1], 
				ODE => $subs->[$n],
				t0 => 0,
				tf => 0.5 );
	$o->evolve;
	$error = $o->error;	
	@vals =  $o->values_at($x);
	$res = abs( $vals[0] - (1-$n)*($x+1/(1-$n)) ** (1/($n-1))  );
	ok( $res < $error, "$n-th order nonlinear: res=$res, expected error=$error"); 

}
}
sub DElog { my ($t,$y) = @_; return 1/$t; }
# y' = x^-1, y(1) = 1 
#  Solution: y = ln(x)
$o = new Math::ODE (    step => 0.1,
                        initial => [0], 
                        ODE => [ \&DElog ], 
                        t0 => 1,
                        tf => 10 );
if ( $o->evolve ) {
	my $x = 5;
	$error = $o->error;	
	@vals =  $o->values_at($x);
	$res = abs( $vals[0] - log $x );
	ok( $res < $error, "1-th order non-autonomous: res=$res, expected error=$error"); 
} else {
	ok( 0, 'numerical badness');
}

